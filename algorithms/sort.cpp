/*
 * sort.cpp
 *
 * Source File
 *
 * Copyright (C) 2014-2015  Yaochuang Ding - <ych_ding@163.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to 
 * deal in the Software without restriction, including without limitation the 
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions, and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution, and in the same 
 *    place and form as other copyright, license and disclaimer information.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
 * THE SOFTWARE.
 *
 */
 
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cassert>
#include "Logger.h"

//using namespace std;

#define BUFSIZE 1024
#define LINE_TO_STRING(x) #x 
#define FILE_AND_LINE (__FILE__":"LINE_TO_STRING(__LINE__)) 

#define PERFORMANCE_METER

typedef enum tagLogLevel
{
LOG_LEVEL_ERR,
LOG_LEVEL_INFO,
LOG_LEVEL_DBG,
LOG_LEVLE_ALL,
} LogLevel;

LogLevel gCurLoglevel = LOG_LEVLE_ALL;

#define LOG_D(fmt, ...)  do { if (gCurLoglevel >= LOG_LEVEL_DBG) fprintf(stdout,"[ DEBUG ] "fmt,##__VA_ARGS__ ); } while(0)
#define LOG_E(fmt, ...)  do { if (gCurLoglevel >= LOG_LEVEL_ERR) fprintf(stdout,"[ ERROR ] "fmt,##__VA_ARGS__ ); } while(0)
#define LOG_I(fmt, ...)  do { if (gCurLoglevel >= LOG_LEVEL_INFO) fprintf(stdout,"[ INFO ] "fmt,##__VA_ARGS__ ); } while(0)

typedef unsigned char uint8_t;
typedef unsigned int uint32_t;

typedef int DataType;

#define DATA_SET_SIZE (100 * 10000)

int gRawDataSet[DATA_SET_SIZE];
int gDataSetCount = 0;

/* produce n random integer number. */
void prepare_random_data(int n)
{    
    ENTER_FUNCTION;
    
    #ifdef PERFORMANCE_METER
    time_t tm1, tm2;
    time(&tm1); /* get current time */
    #endif

    srand(time(NULL)); 
    for (int i = 0; i < n; i++ )
    {        
        gRawDataSet[i] = rand() % (n * 10);// % DATA_SET_SIZE;
    }

    #ifdef PERFORMANCE_METER
    time(&tm2);
    double seconds = difftime(tm2, tm1); /* return double */
    printf("[Prepare data time] = %.lf seconds!\n", seconds);
    #endif

    EXIT_FUNCTION;
}

/* 
 * generate m distinct sorted random number in [0, n) scope.

 *
 * rand(): Returns a pseudo-random integral number in the range [ 0, RAND_MAX]
 * This number is generated by an algorithm that returns a sequence 
 * of apparently non-related numbers each time it is called. 

 * This algorithm uses a seed to generate the series, which should be 
 * initialized to some distinctive value using function srand.
 * http://www.cplusplus.com/reference/cstdlib/rand/?kw=rand  for details.
 * 

 * double difftime (time_t end, time_t beginning)
 * Calculates the difference in seconds between beginning and end.
 * this is an inexact method to meter the performance!
 */
void gen_distinct_rand(int m, int n)
{
    ENTER_FUNCTION;
    
    #ifdef PERFORMANCE_METER
    time_t tm1, tm2;
    time(&tm1); /* get current time */
    #endif
    int i, j;
    srand(time(NULL)); 
    for (i = 0; i < n; i++) //generate sorted random number i
    {            
        if (rand() % (n - i) < m)
        {    
            m--;
            gRawDataSet[gDataSetCount++] = i; 
            logger << i << std::endl;      
        }
    }

    #ifdef PERFORMANCE_METER
    time(&tm2);
    double seconds = difftime(tm2, tm1); /* return double */
    printf("[Run time] %.lf s!\n", seconds);
    #endif

    EXIT_FUNCTION;
}

template <class DataType>
static bool is_sorted(DataType a[], int n)
{
    assert(a != NULL && n > 1);
    for (int i = 0; i < n - 1; i++)
    {    
        if (a[i] > a[i + 1])
        { 
            return false;
        }
    }
    return true;
}

#if 0
/*
 * CAUTION: a b should not refer to the same location
 * The code should be avoid, it is unsafe.
 */
static void swap(DataType &a, DataType &b)
{
    //printf("%d <===> %d \n", a, b);
    a = a ^ b; //printf("a = %d\n", a);
    b = a ^ b; //printf("b = %d\n", b);
    a = a ^ b; //printf("a = %d\n", a);
}
#endif

template <class DataType>
static void swap(DataType &a, DataType &b)
{
   DataType temp = a;
   a = b;
   b = temp;
}

/* print element, each line 10 elements. */
template <class DataType>
static void display(DataType a[], int n)
{
    printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    for (int i = 0; i < n; i++)
    {
       // if ((i) % 10 == 0) printf("+");
        printf("%4d ", a[i]);
        if ((i + 1) % 10 == 0) printf("\n");
    }
    printf("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
}

template <class DataType>
void simple_insert_sort(DataType a[], int n)
{
    ENTER_FUNCTION;
    assert(a != NULL && n > 1);
   
    #ifdef PERFORMANCE_METER
    time_t tm1, tm2;
    time(&tm1); /* get current time */
    #endif

    /* do sorting here */      
    int i, j;
    for (j = 1; j < n; j++)
    {
        DataType temp = a[j];
        for (i = j - 1; i >= 0; i--)
        {    
            if (temp < a[i])
            {    a[i + 1] = a[i];  }
            else 
            {    break;    }
        }
        a[i + 1] = temp; /* find right place for a[j] */
    }

    #ifdef PERFORMANCE_METER
    time(&tm2);
    double seconds = difftime(tm2, tm1); /* return double */
    printf("[Simple insert sort time] = %.lf seconds!\n", seconds);
    #endif

    EXIT_FUNCTION;
}

template<class DataType>
void bubble_sort(DataType a[], int n)
{
    ENTER_FUNCTION;
    assert(a != NULL && n > 1);

    #ifdef PERFORMANCE_METER
    time_t tm1, tm2;
    time(&tm1); /* get current time */
    #endif

    /* do bubble sorting */
    int i, j, sorted = 0;
    for (i = n - 1; !sorted && i > 0; i--) /* each iteration find the right element to a[i]*/
    {
        sorted = 1; /* before checking, suppose [0, i-1] is sorted */
        for (j = 0; j < i; j++)
        {
            if (a[j] > a[j + 1]) /* unsorted element is detected. */
            {
                swap(a[j], a[j + 1]);
                sorted = 0;
            }
        }
    }

    #ifdef PERFORMANCE_METER
    time(&tm2);
    double seconds = difftime(tm2, tm1); /* return double */
    printf("[bubble sort time] = %.lf seconds!\tsorted %d elements!\n", seconds, n);
    #endif

    EXIT_FUNCTION;
}

/* quick sort helper which cannot called from outside
 * no need to check parameters.
 * do actual quick sorting here by recursion.
 * partition elements in a[p,q] into two parts.
 * 
 */
template <class DataType>
static void partition(DataType a[], int p, int q)
{
    ENTER_FUNCTION;
    if (p >= q) return; //end condition of recursion
    
    DataType target = a[p]; /* target would be selected randomly */
    int i =p, j = q + 1;
    /* initial condition: a[p, i] < target, [j, inf] > target*/
    while(true)
    {
        do {i++;} while(i <= q && a[i] < target);
        do {j--;} while(a[j] > target);
        if (i > j) break;
        if (i != j) swap(a[i], a[j]);
        //for (int k = p; k <= q; k++) printf("%d ", a[k]);
        //printf("\n");
    }
    /* a[j] <= target, a[j] is the right place for pivot */
    if (j != p)
    {  
        logger << "put " << target << " in " << j << " position." << std::endl;
        swap(a[j], a[p]); 
    }
    
    #ifdef ADEBUG
    logger << "[ ";
    for (int k = p; k <= q; k++) logger << a[k] << " ";
    logger << "]";
    #endif
    
    partition(a, p, j - 1);
    partition(a, j + 1, q);
    EXIT_FUNCTION;
}

/* 
 * clock() : RETURN The number of clock ticks elapsed
 * since an epoch related to the particular program execution. so when the 
 * program is sleeping the time is not caculated! 
 * CLOCKS_PER_SEC is involved when caculating runtime in second unit.
 * quick sort is very fast. so to meter the perfomance, call time() is not practical.
 */
template <class DataType>
void quick_sort(DataType a[], int n)
{
    ENTER_FUNCTION;
    assert(a != NULL && n > 1);

    #ifdef PERFORMANCE_METER
    clock_t clk1, clk2;
    clk1 = clock(); /* get current clcok ticks elapsed since epoch */
    #endif
    
    partition(a, 0, n - 1); /* do sorting */

    #ifdef PERFORMANCE_METER
    clk2 = clock();
    float seconds = ((float)(clk2 - clk1)) / CLOCKS_PER_SEC; /* calculate in seconds units */
    printf("[quick sort time] = %ld ticks, %.4f seconds!\tsorted %d elements!\n", clk2 - clk1, seconds, n);
    #endif

    EXIT_FUNCTION;
}

/* priority queue 
 * class template definition 
 * The heap is Min heap. the elements at heap top is minimum.
 * */
template <class T>
class PriQueue
{
private:
    T *_p;
    int _n, _maxsize;
    void swap(int i, int j)
    { T temp = _p[i]; _p[i] = _p[j]; _p[j] = temp;    }

public:
    PriQueue(int m)
    : _maxsize(m)
    , _n(0)
    {
        _p = new T[_maxsize + 1];
    }
    
    /* implementation in class definition will be inline */
    void insert(T t) 
    {
        int i, p;
        _p[++_n] = t; /* insert elements from tail, shift up to maintain the heap structure */
        for (i = _n; i > 1 && _p[p = i / 2] > _p[i]; i = p) 
        { swap(p, i); }
    }

    T extract_min()
    {
        int i, c;
        T t = _p[1]; /* remove the min containing in _p[1] */
        _p[1] = _p[_n--]; /* replace [1] with elements in tail and shit down to maintain */
        for (i = 1; (c = 2 * i) <= _n; i = c)
        {
            if ( (c + 1) <= _n && _p[c + 1] < _p[c]) c++; /* find min child */
            if ( _p[i] < _p[c]) break; /* heap maintain ok */
            swap(i, c);
        }
        return t;
    }
};

/* heap sort based on priority queue */
template <class DataType>
void heapSort(DataType a[], int n)
{
    PriQueue<DataType> prique(n);
    for (int i = 0; i < n; i++)
    {
        prique.insert(a[i]);
        logger << "Insert " << a[i] << " into min heap." << std::endl;
    }
    for (int i = 0; i < n; i++)
    {
        a[i] = prique.extract_min();
        logger << "Extract " << a[i] << " from min heap." << std::endl;
    }
}

#define BIT_SORT_MASK   0X1F   //
#define BIT_SORT_SHIFT     5   // 2 ^ 5 == 32
#define BIT_PER_WORD      32
#define MAX_INPUT_NUM     (1000 * 10000)
#define BIT_MAP_SIZE      (1 + MAX_INPUT_NUM / BIT_PER_WORD)
int BitMap[BIT_MAP_SIZE] = { 0 };

void set(unsigned int i) {             BitMap[i >> BIT_SORT_SHIFT] |=  (1 << (i & BIT_SORT_MASK));}
void clr(unsigned int i) {             BitMap[i >> BIT_SORT_SHIFT] &= ~(1 << (i & BIT_SORT_MASK));}
int test(unsigned int i) { return      BitMap[i >> BIT_SORT_SHIFT] &   (1 << (i & BIT_SORT_MASK));}

/* bit sort requires that no duplicate element in unsorted set
 * 1. read unsorted set & build the bit map
 * 2. check the bit map orderly, output element according to checking
 * */
void bit_sort(DataType a[], int n)
{
    
    for (int i = 0; i < n; i++)
    { set(a[i]); }
    for (int i = 0; i < MAX_INPUT_NUM; i++)
    { 
        if (test(i)) 
        { printf(" %d ", i); }
    }
}

enum 
{
    SORT_TYPE_SIMPLE_INSERT = 0,
    SORT_TYPE_BUBBLE,
    SORT_TYPE_QUICK_SORT,
    SORT_TYPE_BIT_SORT,
    SORT_TYPE_Heap_SORT,
    SORT_TYPE_COUNT,
};
const char* sort_type_name [SORT_TYPE_COUNT] = 
{
    "Simple insert Sort",
    "Bubble Sort",
    "Quick Sort",
    "Bit Sort",
    "Heap Sort"
};

typedef void (*SortFunction)(DataType a[], int n);

SortFunction sort_func_tbl[SORT_TYPE_COUNT] = 
{
    simple_insert_sort,
    bubble_sort,
    quick_sort,
    bit_sort,
    heapSort,
};



int main(int argc, char** argv)
{
    logger.setLevel(DEBUG);
    logger.setLineLevel(DEBUG);
    ENTER_FUNCTION;

    if (argc != 4)
    {
        printf("usage error!\n"
                "%s [sort type] [input size] [iteration number]\n", argv[0]); 
        return -1;
    }
    int type, n, m;
    type = atoi(argv[1]);
    n = atoi(argv[2]);
    m = atoi(argv[3]);
    logger << DEBUG << "type = " << type << " m = " << m << " n= " << n << std:: endl;
    if (n > DATA_SET_SIZE)
    {
        logger << ERROR << "input size invalid." << std::endl;
        return -2;
    }
    for (int i = 0; i < m; i++)
    {
        prepare_random_data(n);
        printf("Before\t Sorted ?  %d\n", is_sorted(gRawDataSet,n));
        display(gRawDataSet,n);
        sort_func_tbl[type](gRawDataSet, n);
        printf("After\t Sorted ?  %d\n", is_sorted(gRawDataSet,n));
        display(gRawDataSet,n);
        printf("=============================================================\n");    
    }
    EXIT_FUNCTION;
    return 0;
}

