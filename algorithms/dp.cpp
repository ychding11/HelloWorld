/*
 * Copyright (C) 2014-2016  Yaochuang Ding - <ych_ding@163.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to 
 * deal in the Software without restriction, including without limitation the 
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions, and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution, and in the same 
 *    place and form as other copyright, license and disclaimer information.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
 * THE SOFTWARE.
 *
 */
#include <iostream>
#include <vector>
#include <cstdlib>

//using namespace std;
using std::vector;  //better 
using std::max;  //better 


/*************************************************
 * Function: Given a mxn array, each cell of the
 * array contains an integer number. Caculcate number
 * of paths from left up to bottom right with constraint
 * that path sum equal to K
 *   
 * Param[in]:   
 * Param[in]:   
 * Param[in]:   
 * Param[in]:   
 * Param[in]:   
 *   
 * Retrun: int, path number 
 * Ideas: Recursion on a matrix. Each move has two
 * choices.
 * Notice:  Handle boundary. 
 * TODO: any better solutions?
*************************************************/
int pathNumberWithK(const vector<vector<int>> &a, int m, int n, int c, const int K)
{
	if (m < 0 || n < 0) return 0;
	if (m == 0 && n == 0)
	{
		if (c + a[m][n] == K) return 1; // !caution
	    else return 0;
	}
	return pathNumberWithK(a, m -1, n, c + a[m][n], K) +
	    	pathNumberWithK(a, m, n - 1, c + a[m][n], K);
}


/*************************************************
 * Function: 
 *   
 * Param[in]:   
 * Param[in]:   
 *   
 * Retrun: int, all possible coin change method 
 * Ideas: I can apply tree structure to explain 
 * my solution. 'money' as root, each edge has 
 * a value corresponding to coins[i], a new node
 * is generated by substrabt current weight value
 * from current node, if the substrabtion is 0,
 * then you get a terminal node. the terminal 
 * node number is result.
 *
 * Notice: The solutions has some defact. For 
 * example, {4, [1, 2, 3]} as input. there are
 * <1, 1, 1, 1,> <1, 1, 2>, <2, 2>, <1, 3> totally
 * 4 methods.
 * But use the following solution, it gives 7 methods.
 * The additional methods are <3, 1>, <2, 1, 1> and 
 * <1, 2, 1>
*************************************************/
int coinChange(int money, const vector<int> &coins)
{
	int n = coins.size(); // assume n > 0
	if (money == 0) return 1; // !Caution money >= 0 is always true
	int num = 0;
	for (int i = 0; i < n; ++i)
		if(coins[i] < money) num += coinChange(money - coins[i], coins);
	return num;
}

int coinChange(int n, const int *coins, int m)
{
	if (n < 0 || m <= 0) return 0;
	if (n == 0) return 1;
	return coinChange(n, coins, m - 1) + coinChange(n - coins[m - 1], coins, m);
}

/*************************************************
 * Function: 
 *   
 * Param[in]:   
 * Param[in]:   
 *   
 * Retrun: int, min number of coins 
 * Ideas:
 * f(n), minimum number of coins for money n.   
 * f(0) = 0.
 * f(n) = min {f(n - coins[i])} + 1, n >= coins[i].	 
 * Notice:   
*************************************************/
int coinChangeWithMinCoins(int money, const vector<int> &coins)
{
}

/*************************************************
 * Function: Given a grid with each cell containing 
 * an integer value. Calculate the max path sum 
 * from (0, 0) --> (m-1, n-1). For each cell, only 
 * two direction is possible: right, down.
 *   
 * Param[in]:  array,  
 *   
 * Retrun: int, max path sum 
 * Ideas: Dynamic Programming 
 * f(i,j) : max path sum of (0,0) --> (i, j)
 * f(i,j) = max{f(i, j-1), f(i-1, j)} + grid[i][j], i>0, j>0
 *
 * Notice:  Handle boundary with caution 
*************************************************/
int maxPathSumOfGrid(const vector<vector<int>> &grid)
{
   int m = grid.size();
   if (m <= 0) return 0;
   int n = grid[0].size();
   if (n <= 0) return 0;
   vector<vector<int>> pathSum(m, vector<int>(n, 0));
   pathSum[0][0] = grid[0][0];
   int i, j;
   for (i = 1; i < n; ++i) pathSum[0][i] = pathSum[0][i - 1] + grid[0][i];
   for (i = 1; i < m; ++i) pathSum[i][0] = pathSum[i - 1][0] + grid[i][0];
   for (i = 1; i < m; ++i)
       for (j = 1; j < n; ++j)
	   {
		   pathSum[i][j] = max(pathSum[i][j - 1], pathSum[i - 1][j]) + grid[i][j]; 
	   }
   return pathSum[m - 1][n - 1];
}

int allPathsOfGrid(const vector<int> &grid, int n)
{

}

int minInitialValueOfGrid(const vector<int> &grid, int n)
{

}



int main()
{
	return 0;
}
